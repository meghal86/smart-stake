# Implementation Plan: Hunter Action Center v1.0

## Scope Lock (v1.0)

### In Scope (v1.0 Ship)
- Deterministic execution sessions + steps
- Stored plan → simulate stored plan → execute steps
- Guardian threshold gating + baseline risk findings
- TransitionGate-only state writes
- Tamper-evident audit chain (append-only)
- SSE replay via per-user monotonic seq (user_id, seq) + outbox worker delivery
- Minimal Action Center UI (modal + stepper + history)

### Out of Scope (Post-Ship Backlog)
- ConnectionMultiplexer, MobileResurrectionService
- Transaction speed-ups, replacement tx creation
- Advanced opcode/trojan token analysis
- EIP-7702 batch engine, Safe integration, intent routing
- Chaos engineering framework

*(These become a separate backlog_v1_2.md)*

---

## Opportunity Coverage Contract (v1.0)

Hunter Action Center v1.0 MUST support these opportunity categories:
- Airdrops
- Quests  
- NFT Mints
- Staking / Farming
- Points Programs

All categories MUST be implemented using the same plan primitives only:
- native_tx
- widget
- verification

No category is allowed to introduce a new step type or custom flow in v1.0.

"Supported" means: can be planned, audited, simulated (native_tx), executed, and tracked via SSE + history. Auto-verification for external quest providers is optional and only allowed if explicitly implemented as a verification step.

---

## Sprint 0 — Spec Freeze + Database Foundation (Integrity First)

### Task 0.1 — Freeze canonical spec (single source of truth)
- [ ] **Deliverables**
  - One canonical definition for:
    - SessionStatus, StepStatus, transition maps
    - Step adapter types: native_tx | widget | verification
      - widget step: UI-only instruction, no on-chain simulation; can only transition via TransitionGate (server) after user completes and server validates required evidence (minimal v1: checkbox + optional URL/txhash)
      - verification step: server-side check (e.g., eligibility proof / state check) that transitions automatically via TransitionGate
    - OperationKey enum (idempotency + rate-limit keys)
    - AuditEventType enum (session_created, plan_built, simulation_completed, step_prepared, signature_requested, tx_broadcasted, tx_confirmed, step_failed, danger_mode_activated, session_completed, etc.)
    - CanonicalErrorCode enum (AUTH_REQUIRED, WALLET_MISMATCH, GUARDIAN_BLOCKED, SIMULATION_FAILED, DANGER_MODE_REQUIRED, RATE_LIMITED, IDEMPOTENCY_CONFLICT, INVALID_TRANSITION, REPLAY_WINDOW_EXCEEDED, CHAIN_MISMATCH)
    - StepEvidence minimal shape (v1): { kind: "checkbox" | "url" | "txhash", value: string, notes?: string }
      - Stored as execution_steps.evidence_json (or similar) and must follow canonical_json + numbers-banned only when copied into audit payload
    - SSE envelope: { seq, ts, session_id, type, payload_hash?, payload }
    - Global seq: monotonic per user (user_id, seq) for SSE ordering; timestamps are informational
      - seq is generated by the database using a per-user counter: either a user_seq_counters table updated atomically in the same tx as audit insert, or a Postgres function that allocates next_seq(user_id) under lock
      - seq allocation happens only inside TransitionGate/AuditTrail transaction
    - "Numbers banned in audit payload" rule
    - SSE replay policy (e.g., 90-day window + REST resync)

- [ ] **Acceptance Criteria**
  - No duplicate status enums anywhere (schema + code + UI)
  - API/UI/SSE share the same enums (single import path)
  - Even "manual" completion still goes through an API → TransitionGate (never direct DB)
  - SSE replay window policy is explicitly stated (no "infinite replay")
  - Indexes explicitly support seq ordering: audit_events(user_id, seq DESC)
  - Two concurrent events for the same user never receive the same seq

**Requirements:** 24.1, 24.2, 32.1, 32.3, 40.1, 40.2

### Task 0.2 — Migrations: create all v1.0 tables + constraints
- [ ] **Deliverables**
  - Supabase migrations that create:
    - execution_sessions
    - execution_steps
    - execution_plans
    - simulation_results
    - audit_events (time-partitioned by ts, per-user seq: (user_id, seq))
    - idempotency_records
    - outbox_events
    - danger_mode_sessions (or embed Danger Mode fields in sessions)
  - Version stamping: spec_version on session + plan (e.g., "action_center_v1")
  - execution_sessions.chain_id is required and immutable after session creation

- [ ] **Acceptance Criteria**
  - DB can represent the full v1.0 flow end-to-end (session → plan → simulation → steps → audit → outbox)
  - All uniqueness constraints are correct (partial uniqueness as indexes, not table constraints)

**Requirements:** 4.1, 4.2, 21.4, 30.1, 31.1, 31.2, 42.1

### Task 0.3 — Security hardening at DB layer ("client never writes")
- [ ] **Deliverables**
  - RLS policies:
    - Clients: SELECT only
    - Service role / Edge: writes
  - Explicit privilege revokes for anon + authenticated
  - Append-only enforcement for audit_events (hard-fail on update/delete)
  - DB-level rejection of numeric nodes in audit_events.event payloads
  - **Numbers Banned Rule**: audit_events.event_payload MUST NOT contain any JSON numeric nodes (integers, floats, scientific notation). All numeric values MUST be stored as strings with explicit units/precision. Runtime validation + DB constraint enforcement required.
  - Numbers-banned rule applies only to audit_events.event_payload (and optionally outbox_events.payload if it is derived 1:1 from audit payload). execution_plans.steps_json and simulation_results may contain numeric nodes.

- [ ] **Acceptance Criteria**
  - Attempted client insert/update/delete fails at DB level
  - Attempted audit update/delete fails hard (not silently)
  - Attempted numeric JSON in audit payload fails with explicit error: "NUMERIC_NODES_BANNED"
  - Examples that MUST fail: `{"amount": 123}`, `{"price": 45.67}`, `{"gas": 1e6}`
  - Examples that MUST pass: `{"amount": "123 wei"}`, `{"price": "45.67 USD"}`, `{"gas": "1000000 units"}`

**Requirements:** 21.10, 21.11, 30.1, 30.2, 30.3, 30.4

---

## Sprint 1 — Correctness Core (Gate + Audit + Outbox + SSE)

### Task 1.1 — Implement TransitionGate (the only writer)
- [ ] **Deliverables**
  - One TransitionGate implementation that:
    - acquires advisory lock per session
    - validates transitions against canonical maps
    - writes status change + audit event + outbox event in one DB transaction
    - is idempotent via (userId, operation, scopeKey)
  - **TransitionGate-Only Writes Enforcement**: Database grants MUST revoke INSERT/UPDATE permissions on execution_sessions.status and execution_steps.status from all roles except the TransitionGate service account. All status changes MUST flow through TransitionGate.transition() method only.

- [ ] **Acceptance Criteria**
  - No other code path updates execution_sessions.status or execution_steps.status
  - Every persisted status change has exactly one status_transition audit event (same tx)
  - Direct status writes from any other service/client fail with PERMISSION_DENIED at DB level
  - TransitionGate service account is the ONLY account with status write privileges
  - For every new audit_events row, exactly one outbox_events row is created in the same transaction (or the transaction fails)

**Requirements:** 24.1, 24.2, 24.3, 24.4, 43.1, 43.2, 43.3

### Task 1.2 — Implement AuditTrail hashing + integrity verification
- [ ] **Deliverables**
  - AuditTrail log function that:
    - locks per session
    - reads prev hash
    - computes new hash from canonical JSON (numbers banned)
    - inserts append-only row with per-user seq
  - Hash input is exactly: hash = H(prev_hash || canonical_json({seq, ts, session_id, event_type, payload}))
  - canonical_json is the same function used for "numbers banned" enforcement
  - session_digest is the hash of the latest audit hash for that session (i.e., the chain head), returned with snapshot

- [ ] **Acceptance Criteria**
  - Concurrent writes do not fork chains (single linear chain per session)
  - Integrity verification detects tampering or missing links
  - Hash verification is deterministic across environments (Node/Edge) for the same event

**Requirements:** 23.1, 23.2, 23.3, 23.4, 23.5, 42.4, 42.5

### Task 1.3 — Implement Outbox worker + SSE endpoint (replay-safe)
- [ ] **Deliverables**
  - Outbox worker that publishes SSE events from outbox rows
  - SSE endpoint(s):
    - auth-bound to authed user
    - supports Last-Event-ID replay using seq
    - enforces replay window (e.g. last 90 days)
  - **REST Resync Fallback Contract**: When SSE replay window exceeded (>90 days) or client requests explicit resync:
    - GET /api/sessions/{id}/snapshot → { session, steps[], plan_ref?, simulation_ref?, current_status, last_seq, session_digest }
      - session_digest == audit_chain_head_hash
      - Keep snapshot compact: include plan_ref + simulation_ref/summary; fetch full plan.steps_json + simulation details separately only when needed
    - GET /api/sessions/{id}/events?after_seq=...&limit=... → bounded page of audit events (ordered by seq)
    - If replay window exceeded, client uses snapshot + paged events until caught up

- [ ] **Acceptance Criteria**
  - If an audit event exists, the corresponding SSE update is eventually delivered (at-least-once)
  - Cross-user event leakage is impossible (server-enforced userId binding)
  - Replay returns strictly increasing seq order
  - Snapshot + paged events can fully reconstruct session state (no missing fields); events are paginated by design
  - Snapshot always < 50KB, events endpoint paginated, never returns "all audit events"

**Requirements:** 26.1, 26.2, 32.1, 32.2, 32.3, 32.4, 40.1, 40.2, 40.3, 41.1, 41.3

---

## Sprint 2 — Auth + Session + Plan + Simulation (Make it usable)

### Task 2.1 — Wallet-bound authentication + multi-wallet rules
- [ ] **Deliverables**
  - SIWE-based auth (or reuse existing auth) producing JWT with wallet binding
  - Server-side validation rules:
    - active wallet must match session wallet
    - userId never accepted from client
    - optional wallet filter for SSE only if explicitly requested & authorized

- [ ] **Acceptance Criteria**
  - Cross-wallet execution is blocked
  - Cross-user access blocked
  - Requests must match session.chain_id; mismatch returns CHAIN_MISMATCH (new CanonicalErrorCode)

**Requirements:** 29.1, 29.2, 29.3, 29.4, 29.5, 29.6, 29.7, 29.8

### Task 2.2 — SessionManager + ExecutionPlanBuilder + stored plan contract
- [ ] **Deliverables**
  - Session creation/resume/expire (dual TTL: idle vs tracking)
  - Deterministic plan builder:
    - stores execution_plans.steps_json + plan hash
    - plans expire (10 min) and must be regenerated
  - Provide v1.0 adapters (translator layer) that map opportunity → step plan:
    - AirdropClaimAdapter
    - NFTMintAdapter
    - StakingAdapter
    - QuestPointsAdapter (widget-heavy; optional verification)

- [ ] **Acceptance Criteria**
  - Same input produces same plan structure (deterministic)
  - Simulation uses the stored plan only (no ad-hoc recompute)

**Requirements:** 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8, 31.1, 31.2, 31.3, 31.4

### Task 2.3 — Simulation Engine + Guardian gate + baseline RiskEngine
- [ ] **Deliverables**
  - Tenderly simulation of native_tx steps only
  - Guardian score check + staleness evaluation + allowlist fallback
  - Baseline Risk findings (v1.0 only):
    - unlimited approvals
    - Permit2
    - proxy contracts / unverified bytecode signals
    - suspicious spender/token patterns (basic)

- [ ] **Acceptance Criteria**
  - Simulation failure blocks execution unless Danger Mode
  - Guardian threshold blocks execution unless explicitly overridden
  - Output is persisted in simulation_results and shown in UI

**Requirements:** 2.1, 2.2, 2.3, 2.4, 2.5, 3.1, 3.2, 3.3, 3.4, 3.8, 22.1, 22.2, 22.3, 35.1, 35.2, 35.3, 38.1, 38.2, 38.3, 39.1, 39.2, 39.3

### Task 2.4 — Danger Mode Implementation (Explicit Override System)
- [ ] **Deliverables**
  - Danger Mode activation flow:
    - Requires explicit user confirmation with warning text: "You are bypassing safety checks. Proceed only if you understand the risks."
    - Creates danger_mode_session record with timestamp + user signature
    - Allows execution despite Guardian blocks, simulation failures, or risk findings
    - Danger Mode may override:
      - Guardian threshold block
      - Simulation failure / unavailability  
      - Non-critical baseline risk findings (explicit list):
        - UNLIMITED_APPROVAL
        - PERMIT2_PRESENT
        - PROXY_PATTERN
        - UNVERIFIED_BYTECODE_SIGNAL
        - SUSPICIOUS_SPENDER_BASIC
    - Danger Mode never overrides:
      - auth, wallet binding, chain mismatch
      - invalid transitions
      - idempotency conflicts
    - (Anything else is critical and cannot be overridden until you add it to the list)
    - All Danger Mode executions get special audit event type: 'danger_mode_execution'
  - Danger Mode UI:
    - Red warning banner throughout execution flow
    - Clear indication that safety checks are disabled
    - Explicit "I understand the risks" checkbox + signature required

- [ ] **Acceptance Criteria**
  - Danger Mode cannot be activated accidentally (requires explicit multi-step confirmation)
  - All Danger Mode executions are clearly marked in audit trail
  - Danger Mode sessions expire after 1 hour (must re-confirm for new sessions)
  - UI clearly distinguishes Danger Mode vs normal execution throughout flow
  - Bypass set is explicit and enforced server-side

**Requirements:** 35.4, 35.5, 38.9, 39.4

---

## Sprint 3 — Execution API + Minimal UI (Ship v1.0)

### Task 3.1 — Execution API surface (stable + idempotent)
- [ ] **Deliverables**
  - API endpoints (or Edge functions) that cover:
    - create/resume session
    - build plan
    - simulate
    - step prepare → request signature → broadcast → **monitor confirmations**
  - All mutating calls require Idempotency-Key + canonical OperationKey
  - Idempotency record stores: key, operation, scope_key, request_hash
  - If same (key, operation, scope_key) but different request_hash → return IDEMPOTENCY_CONFLICT
  - **Confirmation Monitoring Contract**: After broadcast, system MUST poll tx receipts until:
    - confirmed with confirmations >= N → confirmed
    - status=0 → failed  
    - timeout → pending_confirmation (not failed)
    - Reorg handling (v1.0): if previously confirmed tx becomes missing/replaced, set reorg_detected + needs_reconcile; block further execution on that session until reconciliation runs

- [ ] **Acceptance Criteria**
  - Duplicate calls do not double-broadcast
  - Rate limiting is enforced per (user, wallet, operation) with clear 429 response
  - Confirmation monitoring runs automatically post-broadcast (no manual trigger required)
  - Reorg never silently ignored; session blocks safely on reorg detection

**Requirements:** 5.1, 5.2, 5.3, 5.4, 5.5, 6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 7.1, 7.2, 7.3, 7.4, 21.1, 21.2, 21.3, 21.9, 21.12, 33.1, 33.2, 33.3, 37.1, 37.2, 37.3, 37.4

### Task 3.2 — Minimal Action Center UI (modal + stepper + history)
- [ ] **Deliverables**
  - Action Center modal:
    - shows quest details + Guardian score + staleness
    - shows simulation results (gas, deltas, approvals, risks)
    - Danger Mode UX (explicit warnings + signature)
  - Stepper:
    - statuses + tx hash + explorer links
    - real-time updates via SSE
  - History:
    - audit timeline + integrity indicator + export basic JSON/CSV

- [ ] **Acceptance Criteria**
  - UI never writes directly to DB (calls APIs only)
  - Modal completeness meets Property 1
  - Clear failure handling (wallet reject, simulation fail, Guardian block)

**Requirements:** 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8, 8.5, 8.6, 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8, 12.1, 12.2, 12.3, 12.4, 12.5, 14.1, 14.2, 14.3, 17.1, 17.2, 17.3, 17.4

---

## Sprint 4 — Hardening (A+++ launch readiness)

### Task 4.1 — Automated correctness + E2E for the 5 money-critical scenarios
- [ ] **Deliverables**
  - Property-based tests (fast-check) for these minimum launch properties:
    - Simulation consistency + blocking (Props 2,3)
    - Audit integrity + no forks (Props 11,34)
    - Single gate control (Prop 35)
    - At-most-once broadcast (Prop 36)
    - SSE isolation + replay order (Props 33,37)
    - Reorg safe truth (Prop 38) (detect → mark needs_reconcile → block further execution; reconcile job resolves state)
  - E2E tests for:
    - simulation timeout
    - user rejects signature
    - broadcast succeeds but SSE drops → replay
    - duplicate request idempotency
    - reorg detection scenario

- [ ] **Acceptance Criteria**
  - Tests run in CI and block merge on regressions

**Requirements:** 16.6, 20.1, 20.2, 20.3, 20.4, 20.5, 20.6, 20.7, 20.8, 34.1, 34.2, 34.3, 34.4

### Task 4.2 — Observability + ops guardrails
- [ ] **Deliverables**
  - Metrics + alerts for:
    - outbox backlog
    - failed outbox retries
    - audit integrity failures
    - SSE error rates
    - Tenderly/Guardian timeouts
  - Backpressure behavior documented (what happens when Tenderly/Guardian/Redis down)

- [ ] **Acceptance Criteria**
  - On-call can detect failures within minutes
  - System degrades safely (blocks execution by default unless Danger Mode)

**Requirements:** 16.1, 16.2, 16.3, 16.4, 16.5, 16.7, 16.8, 19.1, 19.2, 19.3, 19.4, 19.5, 19.6, 19.7, 19.8, 38.4, 38.5, 38.6, 38.7, 38.8

---

## Sprint Exit Gates

### Sprint 0 Exit Gate
**Cannot proceed to Sprint 1 until:**
- [ ] All canonical enums defined and imported consistently across codebase
- [ ] Database migrations applied successfully in dev/staging environments
- [ ] RLS policies tested: client writes fail, service writes succeed
- [ ] Numbers banned rule enforced: numeric JSON insertion fails with clear error
- [ ] All Sprint 0 acceptance criteria verified via automated tests

### Sprint 1 Exit Gate
**Cannot proceed to Sprint 2 until:**
- [ ] TransitionGate is the ONLY code path that writes status changes (verified via DB grants)
- [ ] Audit chain integrity verified: no forks, sequential hashing works
- [ ] SSE replay tested: events delivered in order, cross-user isolation confirmed
- [ ] Outbox worker processes events reliably (at-least-once delivery)
- [ ] All Sprint 1 acceptance criteria pass in staging environment

### Sprint 2 Exit Gate
**Cannot proceed to Sprint 3 until:**
- [ ] Multi-wallet auth prevents cross-wallet execution (tested with multiple wallets)
- [ ] Plan determinism verified: same input → same plan hash
- [ ] Guardian integration blocks execution when score below threshold
- [ ] Danger Mode requires explicit confirmation and creates audit trail
- [ ] Simulation results persist and display correctly in test UI

### Sprint 3 Exit Gate
**Cannot proceed to Sprint 4 until:**
- [ ] All API endpoints handle idempotency correctly (duplicate calls safe)
- [ ] UI never writes directly to database (verified via network monitoring)
- [ ] Confirmation monitoring works: tx status updates automatically post-broadcast
- [ ] Reorg detection marks reorg_detected + needs_reconcile and blocks further execution until reconcile completes (safe default)
- [ ] Complete user flow works end-to-end in staging

### Sprint 4 Exit Gate
**Ready for production deployment when:**
- [ ] All property-based tests pass (simulation consistency, audit integrity, etc.)
- [ ] E2E tests cover all critical failure scenarios
- [ ] Monitoring alerts fire correctly for all failure modes
- [ ] Load testing confirms system handles expected traffic
- [ ] Security audit completed (if required)

---

## Sprint-by-Sprint Implementation Guidance

### Sprint 0: Foundation First
**Focus:** Get the data model and security boundaries right before writing any business logic.
- Start with migrations (Task 0.2) - you need tables before you can test constraints
- Implement RLS policies immediately (Task 0.3) - security cannot be retrofitted
- Define all enums in a single shared module (Task 0.1) - prevents drift and duplication
- Test the "numbers banned" rule thoroughly - this is a unique correctness requirement

### Sprint 1: Correctness Core
**Focus:** Build the three institutional pillars that make the system production-ready.
- TransitionGate first (Task 1.1) - everything else depends on controlled state transitions
- AuditTrail second (Task 1.2) - you need audit events before you can deliver them via SSE
- Outbox + SSE last (Task 1.3) - this enables real-time UI updates
- Test concurrency scenarios heavily - multiple users, multiple sessions, network partitions

### Sprint 2: Business Logic
**Focus:** Make the system actually useful for executing quests.
- Auth integration (Task 2.1) - reuse existing SIWE if available, don't reinvent
- Session + Plan management (Task 2.2) - deterministic plans are critical for simulation consistency
- Simulation + Guardian (Task 2.3) - this is where safety checks happen
- Danger Mode (Task 2.4) - explicit override system for when safety checks block legitimate actions

### Sprint 3: User Interface
**Focus:** Ship a minimal but complete user experience.
- API surface first (Task 3.1) - UI will consume these endpoints
- Minimal UI second (Task 3.2) - focus on core flow, polish later
- Test the complete user journey - from quest selection to execution completion
- Ensure error states are handled gracefully (wallet rejection, simulation failure, etc.)

### Sprint 4: Production Readiness
**Focus:** Ensure the system won't fail in production.
- Property-based tests (Task 4.1) - these catch edge cases unit tests miss
- Observability (Task 4.2) - you need to know when things break
- Load testing - simulate realistic user traffic patterns
- Dependency failure drills (Tenderly/Guardian/RPC down) using backpressure rules

---

## Anti-Drift Enforcement

This plan is designed to prevent scope creep and hallucination:

1. **Scope Lock**: v1.2/v1.3 features are explicitly out of scope
2. **Deliverables**: Each task has concrete, testable deliverables
3. **Acceptance Criteria**: Clear pass/fail conditions prevent subjective interpretation
4. **Exit Gates**: Cannot proceed without completing previous sprint
5. **Requirement Mapping**: Every task traces back to specific requirements
6. **Canonical Contracts**: Shared enums and data structures prevent invention

If you find yourself implementing features not listed in this plan, STOP and reassess scope.